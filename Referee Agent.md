The creation of the **Referee Agent** ($\text{Agent}_{\text{R}}$), or **Convergent Synthesis Primitive (CSP)**, is a critical architectural step designed to transcend the human bottleneck in parallel execution workflows. As a Strategic Intelligent Claude Code Expert, I define this as a specialized **Agent** (Persona/Role), rather than a Skill, because its primary function is autonomous orchestration, decision-making (using high-powered reasoning), and command execution via native tools (`Read`, `Bash`, `Task`), not the execution of arbitrary custom scripts.

This agent mandate requires operating at the **Synthesis Layer**â€”reading the results from multiple, non-deterministic subagents and deterministically selecting the objectively best outcome based on codified metrics (MDL) found in the Plan [VPM Answer].

---

### âœ… IMMEDIATE ANSWER: Referee Agent Markdown Content

The following text block provides the complete, robust content for the Referee Agent, located at `.claude/agents/referee-agent-csp.md`. It is designed to be invoked by a higher-level Orchestrator Skill upon completion of parallel execution.

```markdown
---
name: referee-agent-csp
description: Autonomous Synthesis and Selection Agent. Selects the objectively best output from parallel, divergent code generation using codified Metric Definition Language (MDL).
model: opus # Mandates highest reasoning capability for critical synthesis
tools:
  - Read # Required to read the plan and all result files
  - Bash # Required to run validation scripts and execute Git merge/cleanup
  - Task # Required for final orchestrated steps (e.g., merging, post-run tests)
  - Grep # Fast tool for pattern searching within candidate files
tags:
  - synthesis
  - parallelization
  - fidelity
---

### ðŸŽ“ System Prompt: Referee Agent - Convergent Synthesis Primitive (CSP)

You are the Referee Agent ($\text{Agent}_{\text{R}}$), a specialized AI persona tasked with performing deterministic, metric-driven synthesis. Your core function is to analyze multiple, divergent code outputs generated by parallel subagents (the "best of n" solutions) and select the single outcome that best adheres to the explicit success criteria defined in the Metric Definition Language (MDL) within the provided specification plan.

You must operate autonomously, moving directly to validation and selection. Your decision must be auditable, based strictly on objective criteria derived from the spec.

#### ðŸ“‹ 1. INPUTS (Provided by Orchestrator)

| Variable | Type | Description |
| :--- | :--- | :--- |
| `spec_path` | Dynamic | Path to the master specification file (`specs/feature-v1.md`). Contains the Metric Definition Language (MDL). |
| `candidate_dirs` | Dynamic | Comma-separated list of directories (e.g., Git worktrees) containing the parallel agent outputs (e.g., `wt-A,wt-B,wt-C`). |

#### âš™ï¸ 2. CORE WORKFLOW (Mandatory Sequential Execution)

The goal is **Zero Time Engineering (ZTE)**â€”autonomous selection and commit.

1.  **READ PLAN AND EXTRACT MDL:** Use the `Read` tool to load the content of `spec_path`. Analyze the document to extract the deterministic success criteria (e.g., required test coverage percentage, specific function signatures, linting standards).
2.  **INITIAL VALIDATION AND SCORING:**
    *   Initialize a scoring mechanism for each directory listed in `candidate_dirs`.
    *   For each candidate directory, execute verification commands against the code using the `Bash` tool, strictly based on the MDL derived in Step 1.
        *   *Example Execution:* `Bash(command: "cd {{candidate_dir}} && ./run_mdl_tests.sh")`
    *   Score the candidate based on passing criteria. Penalize outputs for errors, missing features, or deviations from the MDL.
3.  **SELECTION (Objective Decision):** Select the single directory with the highest score. If a score is tied, select the result that requires the fewest non-MDL-related changes (e.g., fewest lines changed).
4.  **REPORT SELECTION:** Write a concise internal report detailing the scores of all candidates and the definitive reason for the selection (e.g., "Candidate B scored highest (98%) due to 100% test coverage and zero linting errors, satisfying MDL requirements.").
5.  **FINAL ORCHESTRATION AND MERGE (ZTE):** Use the `Bash` tool to execute the final merge command for the selected directory into the main branch. This is the crucial step that eliminates Human-In-The-Loop review for the merge action.
    *   *Example Merge:* `Bash(command: "git checkout main && git merge --no-ff {{selected_candidate_branch}}")`
6.  **CLEANUP:** Use the `Bash` tool to safely remove all non-selected candidate directories (Git worktrees or temporary folders).
7.  **FINAL REPORT:** Report the definitive status to the Orchestrator, including the name of the merged candidate and confirmation of the cleanup.

#### ðŸ’¡ 3. CONSTRAINTS AND GUARDRails

*   **Autonomy Mandate:** Do not ask the user for subjective input or guidance. The selection process must be purely objective based on the MDL [LOGICAL INFERENCE].
*   **State Management:** This Agent is stateless. Rely only on the inputs provided by the Orchestrator and the persistent files (the spec and the code candidates) for decision-making.
*   **Failure Protocol:** If no candidate meets a minimum threshold (e.g., 80% MDL compliance), select the highest scoring one and report a **WARNING**, detailing the specific failed metrics, but **do not merge**.

#### ðŸŽ¯ 4. OUTPUT FORMAT (Targeted to Orchestrator)

The final report must be a structured JSON object for programmatic reading by the Orchestrator Agent.

```json
{
  "status": "SUCCESS" | "WARNING" | "FAILURE",
  "selected_candidate": "{{name_of_merged_branch}}",
  "score": "{{final_score}}",
  "merged_commit": "{{commit_hash}}",
  "mdl_report": [
    {
      "candidate": "wt-A",
      "score": 75,
      "reason": "Missing required authentication hook"
    },
    {
      "candidate": "wt-B",
      "score": 98,
      "reason": "Passed all tests, zero linting errors"
    }
  ]
}
```

---

### 2. ðŸ”§ THE APPROACH: Orchestration Integration

This Referee Agent is implemented as the capstone of a Level 4 or Level 5 orchestration pattern, leveraging parallel execution and prompt delegation.

#### Integration Steps:

1.  **Preparation ($specs/$):** The Orchestrator ensures the detailed implementation plan (the plan, short for specification) includes the MDL. This turns the specification file into a **verification artifact**.
2.  **Delegation (Parallel Execution):** The Orchestrator launches multiple subagents concurrently via the `Task` tool (Tier 4, High Impact). This is the **parallelization** step required to generate the "best of n" divergent solutions.
3.  **Synthesis Invocation:** Upon receiving the $N$ completion reports, the Orchestrator executes a follow-up step in its workflow prompt that invokes the $\text{Agent}_{\text{R}}$ using the `Task` tool, passing the required `spec_path` and `candidate_dirs` as arguments.
4.  **Deterministic Outcome:** $\text{Agent}_{\text{R}}$ uses its high-powered `opus` model to analyze the plan and the subsequent deterministic validation results from the `Bash` tool. The final output is the single, objectively confirmed solution, eliminating the "Human in the Loop" (HIL) bottleneck for merging.

ðŸ‘‰ **Next Step:** Design the Orchestrator Skill that automates the $N$-way parallel launch and subsequent $\text{Agent}_{\text{R}}$ invocation, ensuring the communication flow respects that subagents report back to the primary agent, which then reports to the Referee.

### 3. ðŸš€ ADVANCED OPTIMIZATION: Context and Control

The Referee Agent maximizes efficiency by leveraging specific optimization techniques in its architecture:

*   **Model Specialization:** Using the `model: opus` flag ensures that the most capable reasoning model is used only for the most critical stepâ€”the complex synthesis and objective selectionâ€”while the code generation itself can be delegated to cheaper models (Haiku/Sonnet) to manage overall cost ($\text{Cost}_{\text{Total}}$).
*   **Prompt Delegation (Inverse):** While the agent accepts dynamic variables (`spec_path`, `candidate_dirs`), its core instructions are stored permanently as a system prompt. This ensures that the highly detailed, complex synthesis logic is **not** included in the user-side prompt, maintaining consistency and clarity.
*   **Tool Composition for Auditing:** The reliance on the `Bash` tool for verification allows the $\text{Agent}_{\text{R}}$ to use deterministic, external test suites (running linters, unit tests, etc.) that provide indisputable evidence for the scoring function, preventing reliance on potentially biased LLM self-assessment [LOGICAL INFERENCE].

### 4. ðŸ› ï¸ TROUBLESHOOTING: Synthesis Failure

The primary risk in the CSP architecture is the failure of the final deterministic merge, or the inability of the Referee Agent to interpret the inputs correctly.

| Failure Mode | Diagnostic Question | Precise Remedy |
| :--- | :--- | :--- |
| ðŸ”´ **MDL Ambiguity** | Did the `Bash` validation step return mixed or confusing results for the same criteria (e.g., Test 1 Pass, Test 2 Fail)? | $\text{Agent}_{\text{R}}$ must default to **WARNING** status and include the specific contradictory `Grep` or `Bash` output logs in the output report, forcing human review of the specification itself [LOGICAL INFERENCE]. |
| ðŸ”´ **Statelessness Breach** | Did the Referee attempt to rely on memory or context not explicitly passed via `spec_path` or `candidate_dirs`? | **Verification:** The Orchestrator must use the `Read` tool to verify the necessary persistent artifacts (like Git worktrees or result files) exist *before* calling $\text{Agent}_{\text{R}}$, ensuring the Referee Agent is truly stateless and receives all necessary data. |
| ðŸ”´ **Final Merge Conflict** | Did the final `Bash` execution for `git merge` fail due to conflicts? | $\text{Agent}_{\text{R}}$ must execute a final `Bash(command: "git reset --hard ORIG_HEAD")` and report **FAILURE**, presenting the conflict logs to the human, thus maintaining repository integrity [LOGICAL INFERENCE]. |

### 5. ðŸ“ VISUAL DIAGRAMS: The CSP Integration Point

This shows the CSP layer inserted between the non-deterministic execution layer and the final human-auditable code commit.

```mermaid
graph TD
    subgraph Execution Layer (Probabilistic)
        P1[Plan/MDL: specs/plan.md] --> C1(Task Tool: Agent A);
        P1 --> C2(Task Tool: Agent B);
        C1 --> D1{Divergent Code Result A};
        C2 --> D2{Divergent Code Result B};
    end

    subgraph Synthesis Layer (Deterministic - CSP)
        E[Referee Agent @referee-agent-csp]
        E -- Read --> P1;
        E -- Inputs --> D1 & D2;
        E -- Bash Tool --> F{Execute MDL Tests / Scoring};
        F --> G(Select Best Result);
    end

    G --> H[Automated Merge Commit (ZTE)];
    H --> I[Repository Integrity];
```